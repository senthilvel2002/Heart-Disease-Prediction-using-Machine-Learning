# -*- coding: utf-8 -*-
"""Heart Disease Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bHBpN0MRcCWmYksJcFtqshgJnAZN2DfU

Importing the Dependencies
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

"""Data collection and Processing"""

#loading the csv data to Pandas
heart_data = pd.read_csv('heart_disease_dataset.csv')
#print first 5 rows
heart_data.head()

#print last 5 rows
heart_data.tail()

# no of rows and columns in the dataset
heart_data.shape

# getting some info about the data
heart_data.info()

# checking for missing values
heart_data.isnull().sum()

# statistical measures about the data
heart_data.describe()

# checking the distribution of the target value
heart_data['Heart Disease'].value_counts()

"""## Bar chart for visualizing the person does not have heart disease and person having heart disease"""

# prompt: create an bar chart for visualizing the person does not have heart disease and person having heart disease

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming 'heart_data' DataFrame is already loaded as in your previous code

# Count the occurrences of each target value
heart_disease_counts = heart_data['Heart Disease'].value_counts()

# Create a bar chart
plt.figure(figsize=(8, 6))
sns.barplot(x=heart_disease_counts.index, y=heart_disease_counts.values)
plt.title('Distribution of Heart Disease')
plt.xlabel('Heart Disease (0 = No, 1 = Yes)')
plt.ylabel('Number of Patients')
plt.show()

"""## create an pie chart for visualizing the person does not have heart disease and person having heart disease"""

# prompt: create an pie chart for visualizing the person does not have heart disease and person having heart disease

# Assuming 'heart_data' DataFrame is already loaded as in your previous code

# Count the occurrences of each target value
heart_disease_counts = heart_data['Heart Disease'].value_counts()

# Create a pie chart
plt.figure(figsize=(8, 6))
plt.pie(heart_disease_counts, labels=heart_disease_counts.index, autopct='%1.1f%%', startangle=90)
plt.title('Distribution of Heart Disease')
plt.show()



"""1--> Defective heart
0--> Healthy heart

Splitting the features and data
"""

X = heart_data.drop(columns='Heart Disease', axis=1)
Y = heart_data['Heart Disease']

print(X)

print(Y)



X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, stratify=Y, random_state=2)

print(X.shape, X_train.shape, X_test.shape)


model = LogisticRegression()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
# Assuming 'heart_data' is your original DataFrame

# ... (Your previous code for loading and inspecting the data) ...

# Splitting the features and data
X = heart_data.drop(columns='Heart Disease', axis=1)
Y = heart_data['Heart Disease']

# Get the actual column names from the DataFrame
print(X.columns)

# Perform one-hot encoding on categorical features
# Update the column names to reflect the actual column names
categorical_features = X.select_dtypes(include=['object']).columns.tolist() #Selects only the columns with object or category type, this will dynamically create the list of categorical features
# Alternatively, manually adjust the column names to match those printed above
# categorical_features = ['Sex', 'ChestPainType', 'FastingBS', 'RestingECG', 'ExerciseAngina', 'ST_Slope']
print(categorical_features)
X = pd.get_dummies(X, columns=categorical_features, drop_first=True)  # drop_first to avoid multicollinearity

# Splitting the data into Training data and Testing data
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, stratify=Y, random_state=2)

# Model Training
model = LogisticRegression()

# training the logistic regression model with training data
model.fit(X_train, Y_train)



# accuracy on training data
X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction, Y_train)

print('Accuracy on Training data : ', training_data_accuracy)

# accuracy on training data
X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, Y_test)

print('Accuracy on Test data : ', test_data_accuracy)

"""### Building Predictive System"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

# Assuming 'heart_data' is your original DataFrame and you've loaded it

# ... (Your previous code for loading and inspecting the data) ...

# Get the actual column names from the DataFrame
# ... (Your code for splitting and printing X.columns) ...

# Perform one-hot encoding on categorical features during training
# ... (Your code for one-hot encoding during training) ...


### Building Predictive System

input_data = (50,'Male',308,166,97,'Current','None',7,'No','No','No',2,116,'Yes','Typical Angina')

# Convert input_data to DataFrame for one-hot encoding
# creates a single row dataframe with the same columns as the ORIGINAL heart_data
input_data_df = pd.DataFrame([input_data], columns=heart_data.columns[:-1])
#print(input_data_df) # check what the columns are

# Perform one-hot encoding on the input data using the same columns as in training data
input_data_encoded = pd.get_dummies(input_data_df, columns=categorical_features, drop_first=True)

# Ensure that the input data has the same columns as the training data after encoding
missing_cols = set(X_train.columns) - set(input_data_encoded.columns) #checks if any columns present in training data are missing in the prediction data
for c in missing_cols:
    input_data_encoded[c] = 0 #Add any missing column and set its value to 0 to ensure column consistency
input_data_encoded = input_data_encoded[X_train.columns] # Reorder columns to match training data order

# Convert the encoded DataFrame back to a NumPy array for prediction
input_data_reshaped = input_data_encoded.to_numpy()


prediction = model.predict(input_data_reshaped)
print(prediction)


if (prediction[0]== 0):
  print('The Person does not have a Heart Disease')
else:
  print('The Person has Heart Disease')

"""### SVM METHOD"""

# prompt: produce prediction by using support vector machine

from sklearn.svm import SVC

# ... (Your existing code for data loading, preprocessing, and one-hot encoding) ...

# Model Training using Support Vector Machine
model = SVC(kernel='linear')  # You can experiment with different kernels (e.g., 'rbf', 'poly')
model.fit(X_train, Y_train)

# Model Evaluation
# ... (Your existing code for model evaluation using accuracy_score) ...

# Building Predictive System
# ... (Your existing code for creating input_data and encoding it) ...

prediction = model.predict(input_data_reshaped)
print(prediction)

if (prediction[0]== 0):
  print('The Person does not have a Heart Disease')
else:
  print('The Person has Heart Disease')

"""### Accuracy for this svm method"""

# prompt: accuracy for this svm method

# ... (Your existing code for data loading, preprocessing, and one-hot encoding) ...

# Model Training using Support Vector Machine
model = SVC(kernel='linear')  # You can experiment with different kernels (e.g., 'rbf', 'poly')
model.fit(X_train, Y_train)

# Model Evaluation
# Accuracy on training data
X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction, Y_train)
print('Accuracy on Training data : ', training_data_accuracy)

# Accuracy on test data
X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('Accuracy on Test data : ', test_data_accuracy)
# Building Predictive System
# ... (Your existing code for creating input_data and encoding it) ...

prediction = model.predict(input_data_reshaped)
print(prediction)

if (prediction[0]== 0):
  print('The Person does not have a Heart Disease')
else:
  print('The Person has Heart Disease')

"""### create prediction in random forest method with prediction accuracy"""

# prompt: create prediction in random forest method with prediction accuracy

from sklearn.ensemble import RandomForestClassifier

# ... (Your existing code for data loading, preprocessing, and one-hot encoding) ...

# Model Training using Random Forest
model = RandomForestClassifier(random_state=42)  # You can adjust hyperparameters
model.fit(X_train, Y_train)

# Model Evaluation
# Accuracy on training data
X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction, Y_train)
print('Accuracy on Training data : ', training_data_accuracy)

# Accuracy on test data
X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('Accuracy on Test data : ', test_data_accuracy)

# Building Predictive System
# ... (Your existing code for creating input_data and encoding it) ...

prediction = model.predict(input_data_reshaped)
print(prediction)

if (prediction[0]== 0):
  print('The Person does not have a Heart Disease')
else:
  print('The Person has Heart Disease')

"""### create prediction in knn method with prediction accuracy"""

# prompt: create prediction in knn method with prediction accuracy

from sklearn.neighbors import KNeighborsClassifier

# ... (Your existing code for data loading, preprocessing, and one-hot encoding) ...

# Model Training using K-Nearest Neighbors
model = KNeighborsClassifier(n_neighbors=5)  # You can adjust the number of neighbors
model.fit(X_train, Y_train)

# Model Evaluation
# Accuracy on training data
X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction, Y_train)
print('Accuracy on Training data : ', training_data_accuracy)

# Accuracy on test data
X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('Accuracy on Test data : ', test_data_accuracy)

# Building Predictive System
# ... (Your existing code for creating input_data and encoding it) ...

prediction = model.predict(input_data_reshaped)
print(prediction)

if (prediction[0]== 0):
  print('The Person does not have a Heart Disease')
else:
  print('The Person has Heart Disease')

"""### create prediction in gradient boosting method with prediction accuracy"""

# prompt: create prediction in gradient boosting method with prediction accuracy

from sklearn.ensemble import GradientBoostingClassifier

# ... (Your existing code for data loading, preprocessing, and one-hot encoding) ...

# Model Training using Gradient Boosting
model = GradientBoostingClassifier(random_state=42)  # You can adjust hyperparameters
model.fit(X_train, Y_train)

# Model Evaluation
# Accuracy on training data
X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction, Y_train)
print('Accuracy on Training data : ', training_data_accuracy)

# Accuracy on test data
X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('Accuracy on Test data : ', test_data_accuracy)

# Building Predictive System
# ... (Your existing code for creating input_data and encoding it) ...

prediction = model.predict(input_data_reshaped)
print(prediction)

if (prediction[0]== 0):
  print('The Person does not have a Heart Disease')
else:
  print('The Person has Heart Disease')

"""### create prediction in naive bayes method with prediction accuracy"""

# prompt: create prediction in naive bayes method with prediction accuracy

from sklearn.naive_bayes import GaussianNB

# ... (Your existing code for data loading, preprocessing, and one-hot encoding) ...

# Model Training using Naive Bayes
model = GaussianNB()
model.fit(X_train, Y_train)

# Model Evaluation
# Accuracy on training data
X_train_prediction = model.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction, Y_train)
print('Accuracy on Training data : ', training_data_accuracy)

# Accuracy on test data
X_test_prediction = model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_prediction, Y_test)
print('Accuracy on Test data : ', test_data_accuracy)

# Building Predictive System
# ... (Your existing code for creating input_data and encoding it) ...

prediction = model.predict(input_data_reshaped)
print(prediction)

if (prediction[0]== 0):
  print('The Person does not have a Heart Disease')
else:
  print('The Person has Heart Disease')

"""### create prediction in clustering method with prediction accuracy"""

# prompt: create prediction in clustering method with prediction accuracy

from sklearn.cluster import KMeans
from sklearn.metrics import accuracy_score

# Assuming X_train, X_test, Y_train, Y_test are already defined from your previous code

# Model Training using KMeans (Clustering)
kmeans = KMeans(n_clusters=2, random_state=42)  # Assuming 2 clusters for binary classification
kmeans.fit(X_train)

# Predict cluster labels for the training and testing data
X_train_cluster_labels = kmeans.predict(X_train)
X_test_cluster_labels = kmeans.predict(X_test)

# Map cluster labels to target labels (0 or 1) based on majority class in each cluster
cluster_mapping = {}  # Dictionary to store the mapping
for cluster_label in range(2):
  cluster_data = Y_train[X_train_cluster_labels == cluster_label]
  majority_class = cluster_data.mode()[0]
  cluster_mapping[cluster_label] = majority_class

# Convert predicted cluster labels to target labels using the mapping
Y_train_predicted = np.array([cluster_mapping[cluster_label] for cluster_label in X_train_cluster_labels])
Y_test_predicted = np.array([cluster_mapping[cluster_label] for cluster_label in X_test_cluster_labels])


# Model Evaluation
training_accuracy = accuracy_score(Y_train, Y_train_predicted)
testing_accuracy = accuracy_score(Y_test, Y_test_predicted)

print('Accuracy on Training data : ', training_accuracy)
print('Accuracy on Test data : ', testing_accuracy)

# Building Predictive System (for the same input_data as before)
input_data_cluster_label = kmeans.predict(input_data_reshaped)
predicted_target_label = cluster_mapping[input_data_cluster_label[0]]


print(predicted_target_label)

if predicted_target_label == 0:
  print('The Person does not have a Heart Disease')
else:
  print('The Person has Heart Disease')